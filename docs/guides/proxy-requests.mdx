---
title: Proxy Requests to Figment APIs
slug: /guides/proxy-requests-to-figment-apis
---

import Link from "@docusaurus/Link";
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import CodeBlock from "@theme/CodeBlock";

import img1 from "@site/static/img/guides/proxy-requests/cloudflare_dashboard.png";
import img2 from "@site/static/img/guides/proxy-requests/create_service.png";
import img3 from "@site/static/img/guides/proxy-requests/environment_variables.png";
import img4 from "@site/static/img/guides/proxy-requests/api_key_encrypt.png";
import img5 from "@site/static/img/guides/proxy-requests/env_vars.png";
import img6 from "@site/static/img/guides/proxy-requests/quick_edit.png";
import img7 from "@site/static/img/guides/proxy-requests/code_editor.png";
import img8 from "@site/static/img/guides/proxy-requests/save_and_deploy.png";
import img9 from "@site/static/img/guides/proxy-requests/proxy_send_post_request.png";
import img10 from "@site/static/img/guides/proxy-requests/proxy_response_200.png";

This guide will show you how to deploy a proxy using a Cloudflare worker to remove API Keys from your clientside codebase and provide a foundational middleware for further security controls.

## Motivation

To make use of Figment APIs calls must be <Link to="/quickstart/api-authentication">authenticated using your project's API key</Link>. In certain instances you may want to make calls from client side applications. Doing so directly would mean having the API Key in the client codebase and visible during network requests.
Using a proxy means we can take API Key out of the client side. In addition having a middleware means we can take further steps such as validating CORS Origins, whitelisting IPs, throttling requests and more.

## Disclaimer

It's important to maintain awareness of the security considerations for the environment in which you're operating. The code example we've provided in the guide below is an example to get you started and not meant for production out of the box.

:::caution reminder

Always use <Link to="https://en.wikipedia.org/wiki/Transport_Layer_Security">Transport Layer Security</Link> (TLS), meaning [**WSS**](https://developers.cloudflare.com/workers/learning/using-websockets/) or [**HTTPS**](https://www.cloudflare.com/en-ca/learning/ssl/what-is-https/) protocols.
Traffic sent over **WS** or **HTTP** protocols is not secure, regardless of the method used.

:::

## Cloudflare Service Worker Setup

#### Prerequisites

- A working knowledge of JavaScript.
- Create a [Cloudflare](https://cloudflare.com) account if you do not already have one, sign in to the Cloudflare Dashboard.

### Create a new Service

1. From the Workers Overview tab, click the "Create a Service" button.

<img
  src={img1}
  width="400"
  alt="Cloudflare Dashboard"
  className="shadow--tl inline-image"
/>

2. Give the service a name, then click the "Create service" button.

<img
  src={img2}
  width="400"
  alt="Create a Service"
  className="shadow--tl inline-image"
/>

### Add Environment Variables to Cloudflare

3. From the Settings tab of that worker, add the necessary environment variables.

:::info note

Read more about [environment variables](https://developers.cloudflare.com/workers/platform/environment-variables/#environment-variables-via-the-dashboard) in the Cloudflare documentation.

:::

<img
  src={img3}
  width="400"
  alt="Environment Variables"
  className="shadow--tl inline-image"
/>

- Add an environment variable named `API_KEY`. Click the "Encrypt" button once you've set the value of `API_KEY`.
- Add an environment variable named `ALLOWED_ORIGINS`. The values must be quoted, in an array (`["docs.figment.io"]`). Include the value `null` without quotes _only if you intend to make requests from an environment that does not include an_ `Origin`, (`["docs.figment.io", null]`) .
- Add an environment variable named `PROXY_ORIGIN`. The value must be the URL where the worker is deployed (ex. `https://proxy.yourusername.workers.dev`). If you have set up a custom domain in Cloudflare, use that instead.

<img
  src={img4}
  width="400"
  alt="Encrypt the API key"
  className="shadow--tl inline-image"
/>

<img
  src={img5}
  width="400"
  alt="Add Other Environment Variables"
  className="shadow--tl inline-image"
/>

### Add Proxy Code to Cloudflare Worker

4. Click on the "Quick edit" button, then copy and paste the code from <Link to="#code-explanation">the section below</Link> into the Cloudflare code editor on the left side of the page.

<img
  src={img6}
  width="400"
  alt="Quick Edit"
  className="shadow--tl inline-image"
/>

6. Save and Deploy the code explained below to the worker, making any adjustments required by your specific use case.

<img
  src={img8}
  width="400"
  alt="Save and Deploy"
  className="shadow--tl inline-image"
/>

You can now send requests to Figment APIs and pass responses back to the client without exposing your API keys!

<br />

:::note

Use the example code we've supplied as a starting point for your own proxy!

<details><summary>Click here to view the complete example proxy, â‰ˆ200 lines of code.</summary>

```js
const env = {
  API_KEY: API_KEY,
  ALLOWED_ORIGINS: JSON.parse(ALLOWED_ORIGINS),
  PROXY_HOST: PROXY_HOST,
  ALLOWED_METHODS: ["POST", "GET", "OPTIONS"],
  HOSTS: {
    wss: {
      "node-api": {
        arbitrum: "arbitrum-mainnet-ws-archive-dbgtxn.datahub.figment.io",
        bnb: "bsc--mainnet--ws-archive-dbgtxn.datahub.figment.io",
        celo: "celo-mainnet--ws.datahub.figment.io",
        "cosmos-tendermint-rpc":
          "cosmoshub-4--rpc--archive.datahub.figment.io/websocket",
        ethereum: "ethereum-mainnet--ws.datahub.figment.io",
        fantom: "ftm--mainnet--ws-archive-dbgtxn.datahub.figment.io",
        kusama: "kusama--ws.datahub.figment.io",
        optimism: "optimism-mainnet-ws-archive.datahub.figment.io",
        "osmosis-tendermint-rpc":
          "osmosis-1--rpc--archive.datahub.figment.io/websocket",
        polkadot: "polkadot--ws.datahub.figment.io",
        polygon: "matic-mainnet--ws-archive-dbgtxn.datahub.figment.io",
        solana: "solana--mainnet.datahub.figment.io",
      },
    },
    https: {
      "node-api": {
        arbitrum: "arbitrum-mainnet-rpc-archive-dbgtxn.datahub.figment.io",
        "avalanche-c-chain": "avalanche--mainnet--rpc.datahub.figment.io",
        "avalanche-p-chain": "avalanche--mainnet--rpc.datahub.figment.io",
        "avalanche-x-chain": "avalanche--mainnet--rpc.datahub.figment.io",
        bnb: "bsc--mainnet--rpc-archive-dbgtxn.datahub.figment.io",
        celo: "celo-mainnet--rpc.datahub.figment.io",
        "cosmos-lcd": "cosmoshub-4--lcd--archive.datahub.figment.io",
        "cosmos-tendermint-rpc": "cosmoshub-4--rpc--archive.datahub.figment.io",
        ethereum: "erigon-mainnet--rpc-dbgtxn.datahub.figment.io",
        fantom: "ftm--mainnet--rpc-archive-dbgtxn.datahub.figment.io",
        "kusama-sidecar": "polkadot-kusama--sidecar.datahub.figment.io",
        "mina-graphql": "mina-mainnet--graphql.datahub.figment.io",
        near: "near-mainnet--rpc--archive.datahub.figment.io",
        optimism: "optimism-mainnet-rpc-archive.datahub.figment.io",
        "osmosis-lcd": "osmosis-1--lcd--archive.datahub.figment.io",
        "osmosis-tendermint-rpc": "osmosis-1--rpc--archive.datahub.figment.io",
        "polkadot-sidecar": "polkadot--sidecar.datahub.figment.io",
        polygon: "matic-mainnet--jsonrpc-archive-dbgtxn.datahub.figment.io",
        solana: "solana--mainnet.datahub.figment.io",
      },
      "rewards-api": {
        ethereum: "eth-rewards.datahub.figment.io/v2",
        polkadot: "polkadot-rewards.datahub.figment.io/v2",
        solana: "solana-rewards.datahub.figment.io/v2",
        near: "near-rewards.datahub.figment.io/v2",
      },
      "rewards-rates-api": {
        ethereum: "eth-rewards.datahub.figment.io",
        polkadot: "polkadot-rewards.datahub.figment.io",
        solana: "solana-rewards.datahub.figment.io",
      },
      "transaction-search-api": {
        avalanche: "avalanche--mainnet--indexer.datahub.figment.io",
        "near-protocol": "near--indexer.datahub.figment.io",
      },
      "staking-api": {
        avalanche: "avalanche-slate.datahub.figment.io/api/v1/flows",
        ethereum: "eth-slate.datahub.figment.io/api/v1/flows",
        near: "near-slate.datahub.figment.io/api/v1/flows",
        polkadot: "polkadot-slate.datahub.figment.io/api/v1/flows",
        solana: "solana-slate.datahub.figment.io/api/v1/flows",
      },
      "staking-api-webhooks": {
        avalanche:
          "avalanche-slate.datahub.figment.io/api/v1/webhook_endpoints",
        ethereum: "eth-slate.datahub.figment.io/api/v1/webhook_endpoints",
        near: "near-slate.datahub.figment.io/api/v1/webhook_endpoints",
        polkadot: "polkadot-slate.datahub.figment.io/api/v1/webhook_endpoints",
        solana: "solana-slate.datahub.figment.io/api/v1/webhook_endpoints",
      },
    },
  },
};

/**
 * Builds and returns the URL for the node request
 * @param {Request} request - inbount request
 * @throws {Response} 500 error if network isn't found
 * @returns {URL} of the node endpoint
 */
function buildURL(request) {
  const [base, service, network, ...routes] =
    request.url.split(/(?<!\/)\/(?!\/)/g);

  const protocol =
    request.headers.get("Upgrade") === "websocket" ? "wss" : "https";
  const services = env.HOSTS[protocol][service];
  const url = services ? services[network] : null;
  if (!url) {
    throw new Response(
      `service '${service}' for network '${network}' could not be found`,
      {
        status: 500,
        statusText: `Invalid network`,
      }
    );
  }
  return new URL(
    `${protocol}://${url}/apikey/${env.API_KEY}/${routes.join("/")}`
  );
}

/**
 * Ensures the request is authorized to proceed
 * @param {Request} request - inbound request
 * @throws {Response} 403 or 405 if unauthorized
 */
function ensureAuthorized(request) {
  let error;

  if (!env.ALLOWED_ORIGINS.includes(request.headers.get("Origin"))) {
    error = {
      message: `Origin ${request.headers.get("Origin")} not allowed`,
      status: 405,
      statusText: "Not Allowed",
    };
  } else if (!env.ALLOWED_METHODS.includes(request.method)) {
    error = {
      message: `Method ${request.method} not allowed`,
      status: 405,
      statusText: "Not Allowed",
    };
  } else if (
    request.method !== "OPTIONS" &&
    request.headers.get("Authorization") !== env.API_KEY
  ) {
    error = {
      message: `Not Authorized ${request.method}!`,
      status: 403,
      statusText: "Not Allowed",
    };
  }

  if (error) {
    throw new Response(error.message, {
      status: 403,
      statusText: `Not allowed`,
    });
  }
}

/**
 * Builds and returns preflight response based on request
 * @param {Request} request - inbound request
 * @returns {Response} with required CORS params
 */
function getPreflightResponse(request) {
  return new Response(null, {
    status: 200,
    headers: {
      "Access-Control-Allow-Headers":
        request.headers.get("Access-Control-Request-Headers") || "",
      "Access-Control-Allow-Origin": request.headers.get("Origin") || "",
      "Access-Control-Allow-Methods": env.ALLOWED_METHODS.join(","),
      "Access-Control-Max-Age": "86400",
    },
  });
}

/**
 * Establishes a websocket connection and returns response containing ws client
 * @param {string} url - the figment api url
 * @throws {Response} relays status and statusText if connection fails
 * @returns {Response} with required websocket client
 */
async function getWebsocketConnection(url) {
  const result = await fetch(url, {
    headers: {
      Upgrade: "websocket",
      Authorization: env.API_KEY,
    },
  });

  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/101
  if (result.status !== 101) {
    throw new Response(null, {
      status: result.status,
      statusText: result.statusText,
    });
  }

  // Accept the websocket connection
  const websocket = result.webSocket;
  websocket.accept();

  // Create a client/server to act as the proxy layer
  const clientServerPair = new WebSocketPair();
  const [client, server] = Object.values(clientServerPair);

  // Tell the Workers runtime to listen for WebSocket data & keep the connection open
  server.accept();

  // Any messages from the client are forwarded to the DataHub socket
  server.addEventListener("message", (event) => {
    websocket.send(event.data);
  });

  // Any messages coming from DataHub are forwarded back to the client
  websocket.addEventListener("message", (event) => {
    server.send(event.data);
  });

  return new Response(null, {
    status: 101,
    webSocket: client,
  });
}

/**
 * Fetches results from Figment APIs and returns result
 * @param {string} url - the figment api url
 * @param {Request} request - inbound request
 * @returns {Response} relays Figment API node response
 */
async function getRpcResponse(url, request) {
  const apiRequest = new Request(url, request);
  apiRequest.headers.set("origin", `https://${env.PROXY_HOST}`);

  // create then rebuild a new response from the API result so it's mutable
  let response = await fetch(apiRequest);
  response = new Response(response.body, response);
  response.headers.set(
    "Access-Control-Allow-Headers",
    request.headers.get("Access-Control-Request-Headers") || ""
  );
  response.headers.set(
    "Access-Control-Allow-Origin",
    request.headers.get("Origin") || ""
  );
  response.headers.set(
    "Access-Control-Allow-Methods",
    env.ALLOWED_METHODS.join(",")
  );
  return response;
}

// main function to process the incoming fetch request
addEventListener("fetch", function handleFetch(event) {
  try {
    const { request } = event;
    const url = buildURL(request);
    ensureAuthorized(request);
    if (request.method === "OPTIONS") {
      event.respondWith(getPreflightResponse(request));
    } else if (request.headers.get("Upgrade") === "websocket") {
      event.respondWith(getWebsocketConnection(url));
    } else {
      event.respondWith(getRpcResponse(url, request));
    }
  } catch (error) {
    event.respondWith(error);
  }
});
```

</details>

Continue with the explanation below or proceed to the <Link to="#testing-and-troubleshooting">Testing and Troubleshooting</Link> section.

:::

## Code Explanation

### Environment Variables

The `env` constant contains the values of the Cloudflare environment variables `API_KEY`, `ALLOWED_ORIGINS`, `PROXY_ORIGIN` as well as a list of `ALLOWED_METHODS` and `HOSTS`.

It is also useful to define hostnames for the Figment API endpoints to which we would be sending requests, separated by their protocol &mdash; either WebSocket Secure (`wss`) or SSL (`https`).

`HOSTS` separates `wss` and `https` hostnames, and places them into each applicable service. Figment provides access to infrastructure as well as APIs. One such API is the Node API, allowing clients to communicate directly with Proof-of-Stake networks.

Thus, `env.HOSTS['wss']['node-api'][0]` would refer to the Arbitrum hostname, which is where clients send their requests to the Arbitrum Node API.

<details><summary>Click here to view the code.</summary>

```js {2,3,4,5,6} title="Note: ... indicates where values were removed for display"
const env = {
  API_KEY: API_KEY,
  ALLOWED_ORIGINS: JSON.parse(ALLOWED_ORIGINS),
  PROXY_HOST: PROXY_HOST,
  ALLOWED_METHODS: ["POST", "GET", "OPTIONS"],
  HOSTS: {
    "wss": {
      "node-api": {
        "arbitrum": "arbitrum-mainnet-ws-archive-dbgtxn.datahub.figment.io",
        ...
      }
      ...
    },
    "https": {
      "node-api": {
        "arbitrum": "arbitrum-mainnet-rpc-archive-dbgtxn.datahub.figment.io",
        ...
      }
      ...
    },
  },
};
```

</details>

### Building a Request URL

`buildURL` processes an inbound request, returning the completed URL to be queried. This will be the Figment API endpoint, including the route.

- `protocol` in this scope will be `wss` or `https`. Based on the presence of an `Upgrade` header, we know if the incoming connection is requesting to be upgraded to a WebSocket. Each protocol is handled separately.
- `services` in this scope will be one of the defined keys in `HOSTS`, assigned to either protocol &mdash; ex. `node-api`
- `routes` are passed via the request URL, they indicate which Figment API endpoint to query. For example, `/node-api/solana` would direct the request to the `HOSTS` value for that service and network.

<details><summary>Click here to view the code.</summary>

```js
function buildURL(request) {
  const [base, service, network, ...routes] =
    request.url.split(/(?<!\/)\/(?!\/)/g);

  const protocol =
    request.headers.get("Upgrade") === "websocket" ? "wss" : "https";
  const services = env.HOSTS[protocol][service];
  const url = services ? services[network] : null;
  if (!url) {
    throw new Response(
      `service '${service}' for network '${network}' could not be found`,
      {
        status: 500,
        statusText: `Invalid network`,
      }
    );
  }
  return new URL(
    `${protocol}://${url}/apikey/${env.API_KEY}/${routes.join("/")}`
  );
}
```

</details>

### Restricted Access

We want to restrict access to the proxy to `Origins` and methods which are explicitly allowed.
If the request does not meet these criteria, or if there is an error, we will respond to the request with the appropriate <Link to="/guides/response-codes-and-error-codes">`4xx` status codes</Link>.

<details><summary>Click here to view the code.</summary>

```js
function ensureAuthorized(request) {
  let error;

  if (!env.ALLOWED_ORIGINS.includes(request.headers.get("Origin"))) {
    error = {
      message: `Origin ${request.headers.get("Origin")} not allowed`,
      status: 405,
      statusText: "Not Allowed",
    };
  } else if (!env.ALLOWED_METHODS.includes(request.method)) {
    error = {
      message: `Method ${request.method} not allowed`,
      status: 405,
      statusText: "Not Allowed",
    };
  } else if (
    request.method !== "OPTIONS" &&
    request.headers.get("Authorization") !== env.API_KEY
  ) {
    error = {
      message: `Not Authorized ${request.method}!`,
      status: 403,
      statusText: "Not Allowed",
    };
  }

  if (error) {
    throw new Response(error.message, {
      status: 403,
      statusText: `Not allowed`,
    });
  }
}
```

</details>

### CORS Requests

Handle **C**ross **O**rigin **R**esource **S**haring (CORS) requests by responding with the appropriate headers.

All CORS preflight requests use the `OPTIONS` method but not all `OPTIONS` requests are CORS preflight requests.

What this means in practice is that we must treat all `OPTIONS` requests as CORS preflight requests.

CORS Resources:

- <Link to="/quickstart/settings-and-security#app-security-settings">
    Quick Start: Settings and Security
  </Link>
- <Link to="/guides/troubleshoot-cors-errors">Troubleshooting CORS Errors</Link>

<details><summary>Click here to view the code.</summary>

```js
function getPreflightResponse(request) {
  return new Response(null, {
    status: 200,
    headers: {
      "Access-Control-Allow-Headers":
        request.headers.get("Access-Control-Request-Headers") || "",
      "Access-Control-Allow-Origin": request.headers.get("Origin") || "",
      "Access-Control-Allow-Methods": env.ALLOWED_METHODS.join(","),
      "Access-Control-Max-Age": "86400",
    },
  });
}
```

</details>

### Handle WebSocket Connections

`getWebsocketConnection` handles WebSocket traffic by upgrading the connection, accepting the request, creating a client/server pair, and then `addEventListener` can pass the messages between the client and server.
A successful response must always return status code `101 Switching Protocols`. Read more about the status code, WebSockets and WebSocket security in the <Link to="#references">Reference section</Link> at the end of the guide.

<details><summary>Click here to view the code.</summary>

```js
async function getWebsocketConnection(url) {
  const result = await fetch(url, {
    headers: {
      Upgrade: "websocket",
      Authorization: env.API_KEY,
    },
  });

  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/101
  if (result.status !== 101) {
    throw new Response(null, {
      status: result.status,
      statusText: result.statusText,
    });
  }

  // Accept the websocket connection
  const websocket = result.webSocket;
  websocket.accept();

  // Create a client/server to act as the proxy layer
  const clientServerPair = new WebSocketPair();
  const [client, server] = Object.values(clientServerPair);

  // Tell the Workers runtime to listen for WebSocket data & keep the connection open
  server.accept();

  // Any messages from the client are forwarded to the DataHub socket
  server.addEventListener("message", (event) => {
    websocket.send(event.data);
  });

  // Any messages coming from DataHub are forwarded back to the client
  websocket.addEventListener("message", (event) => {
    server.send(event.data);
  });

  return new Response(null, {
    status: 101,
    webSocket: client,
  });
}
```

</details>

### Handle HTTP Requests

This function uses the `fetch` API after setting the `Authorization` and `Origin` headers.
This is a naive implementation, though it is effective when all you want to do is keep your API key secure.
From the client point of view, the API key is never visible.

<details><summary>Click here to view the code.</summary>

```js
async function getRpcResponse(url, request) {
  const apiRequest = new Request(url, request);
  apiRequest.headers.set("origin", `https://${env.PROXY_HOST}`);

  // create then rebuild a new response from the API result so it's mutable
  let response = await fetch(apiRequest);
  response = new Response(response.body, response);
  response.headers.set(
    "Access-Control-Allow-Headers",
    request.headers.get("Access-Control-Request-Headers") || ""
  );
  response.headers.set(
    "Access-Control-Allow-Origin",
    request.headers.get("Origin") || ""
  );
  response.headers.set(
    "Access-Control-Allow-Methods",
    env.ALLOWED_METHODS.join(",")
  );
  return response;
}
```

</details>

### addEventListener

:::info

The `addEventListener` function defines triggers for a Worker script to execute.

Read more about the [fetch API](https://developers.cloudflare.com/workers/runtime-apis/fetch/) and [`addEventListener`](https://developers.cloudflare.com/workers/runtime-apis/add-event-listener/) in the Cloudflare documentation.

:::

In this case we want to tie all of the functionality together, ensuring requests are handled with the appropriate function. The `try`/`catch` block here is necessary to pass along any errors that occur.

<details><summary>Click here to view the code.</summary>

```js
addEventListener("fetch", function handleFetch(event) {
  try {
    const { request } = event;
    const url = buildURL(request);
    ensureAuthorized(request);
    if (request.method === "OPTIONS") {
      event.respondWith(getPreflightResponse(request));
    } else if (request.headers.get("Upgrade") === "websocket") {
      event.respondWith(getWebsocketConnection(url));
    } else {
      event.respondWith(getRpcResponse(url, request));
    }
  } catch (error) {
    event.respondWith(error);
  }
});
```

</details>

<br />

## Testing and Troubleshooting

In the Cloudflare worker's quick edit view, you can send various HTTP requests directly to the proxy URL.
To verify that the proxy is working with your application:

1. Ensure that you have set your deployed app's hostname in the `ALLOWED_ORIGINS` environment variable.
2. Also ensure the deployed proxy worker's URL is set in the `PROXY_ORIGIN` environment variable.
3. Send a request to the proxy in Cloudflare:
   - If you change the HTTP method in the Cloudflare Service Worker to `POST`, remember to also add a `Content-Type` header with a value of `application/json`.
   - To get the current block height of Solana for example, append the service and network (`/node-api/solana`) to the request URL.
4. Check the response. Status `200` and the expected response from the requested method indicate that all is working as intended.

<img
  src={img9}
  width="400"
  alt="Send a Request From Cloudflare"
  className="shadow--tl inline-image"
/>

<img
  src={img10}
  width="400"
  alt="Figment API Response via Cloudflare Proxy"
  className="shadow--tl inline-image"
/>

### Potential Issues & Solutions

- **415 Unsupported Media Type**

  - Supply a `Content-Type` header of `application/json` when sending a JSON body with `POST` requests.

- **500 Invalid network**

  - Specify the network and service in the request URL. <Link to="#building-a-request-url">Refer to the `buildURL` function</Link>.

## References

- \* [Cloudflare Blog: Introducing Cloudflare Workers](https://blog.cloudflare.com/introducing-cloudflare-workers/)
- [Tim Kleyersburg: Create an API proxy with Cloudflare Workers](https://www.tim-kleyersburg.de/articles/api-proxy-with-cloudflare-workers/)
- [MDN Docs: HTTP Status 101](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/101)
- [PortSwigger Web Security Academy: What are WebSockets?](https://portswigger.net/web-security/websockets/what-are-websockets)
- [Bright AppSec Blog: WebSocket Security](https://brightsec.com/blog/websocket-security-top-vulnerabilities/)

You should now have everything you need in order to successfully implement a proxy as a serverless function. Happy building!
